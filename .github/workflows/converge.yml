# converge.yml â€” Gravix Convergence Pipeline
# Runs gates + triggers holdout scenario validation on feature branches.
#
# Secrets required:
#   HOLDOUT_PAT â€” GitHub PAT with repo scope (cross-repo dispatch to gravix-holdouts)
#   Vercel token â€” already configured via Vercel GitHub integration

name: Converge

on:
  push:
    branches-ignore: [main]
  workflow_dispatch:

concurrency:
  group: converge-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â”€â”€â”€ Gates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Must pass before holdout scenarios run.
  # Mirrors ci.yml structure for consistency.

  gates-frontend:
    name: "Gate: Frontend (lint + types + build)"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Type check
        run: pnpm run type-check

      - name: Lint
        run: pnpm run lint

      - name: Build
        run: pnpm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: https://test.supabase.co
          NEXT_PUBLIC_SUPABASE_ANON_KEY: test-anon-key
          NEXT_PUBLIC_APP_URL: https://gravix.com

  gates-backend:
    name: "Gate: Backend (pytest)"
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.14
        uses: actions/setup-python@v5
        with:
          python-version: "3.14"
          cache: "pip"
          cache-dependency-path: |
            api/requirements.txt
            api/requirements-test.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r api/requirements.txt
          pip install -r api/requirements-test.txt

      - name: Run tests
        run: cd api && python -m pytest tests/ -v --timeout=120
        env:
          SUPABASE_URL: https://test.supabase.co
          SUPABASE_ANON_KEY: test-anon-key
          SUPABASE_SERVICE_KEY: test-service-key
          SUPABASE_JWT_SECRET: super-secret-jwt-test-key-at-least-32-chars-long!!
          ANTHROPIC_API_KEY: sk-ant-test-key
          CRON_SECRET: test-cron-secret
          STRIPE_SECRET_KEY: sk_test_fake
          STRIPE_WEBHOOK_SECRET: whsec_test_fake
          STRIPE_PRICE_ID_PRO: price_test_pro
          STRIPE_PRICE_ID_TEAM: price_test_team
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          RESEND_API_KEY: re_test_fake

  # â”€â”€â”€ Converge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Triggers holdout scenarios against the Vercel preview deployment.

  converge:
    name: "Converge: Holdout Scenarios"
    runs-on: ubuntu-latest
    needs: [gates-frontend, gates-backend]

    steps:
      - uses: actions/checkout@v4

      # Vercel preview URLs use random hashes, not predictable branch names.
      # We poll the Vercel API to find the deployment for this commit SHA.
      - name: Wait for Vercel deployment
        id: preview
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          SHA="${{ github.sha }}"
          PROJECT_ID="${{ secrets.VERCEL_PROJECT_ID }}"
          TEAM_ID="${{ secrets.VERCEL_TEAM_ID }}"
          
          # If no Vercel token/project, fall back to production URL
          if [ -z "$VERCEL_TOKEN" ] || [ -z "$PROJECT_ID" ]; then
            echo "âš ï¸  No VERCEL_TOKEN or VERCEL_PROJECT_ID â€” falling back to gravix.com"
            echo "url=https://gravix.com" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "â³ Waiting for Vercel deployment of ${SHA:0:7}..."
          
          for i in $(seq 1 40); do
            RESPONSE=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
              "https://api.vercel.com/v6/deployments?projectId=${PROJECT_ID}&teamId=${TEAM_ID}&limit=5&state=READY")
            
            # Find deployment matching this commit
            DEPLOY_URL=$(echo "$RESPONSE" | python3 -c "
          import sys, json
          data = json.load(sys.stdin)
          for d in data.get('deployments', []):
              meta = d.get('meta', {})
              if meta.get('githubCommitSha', '').startswith('${SHA:0:12}'):
                  print('https://' + d['url'])
                  break
          " 2>/dev/null)
            
            if [ -n "$DEPLOY_URL" ]; then
              echo "âœ… Found deployment: $DEPLOY_URL"
              echo "url=${DEPLOY_URL}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            
            echo "   Attempt $i/40 â€” not ready yet, waiting 15s..."
            sleep 15
          done
          
          echo "âŒ Timed out waiting for Vercel deployment"
          echo "url=https://gravix.com" >> "$GITHUB_OUTPUT"
          echo "âš ï¸  Falling back to production URL"

      - name: Trigger holdout scenarios
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.HOLDOUT_PAT }}
          repository: ev0lv3vr/gravix-holdouts
          event-type: run-scenarios
          client-payload: >-
            {
              "preview_url": "${{ steps.preview.outputs.url }}",
              "sha": "${{ github.sha }}",
              "branch": "${{ github.ref_name }}",
              "callback_repo": "ev0lv3vr/gravix_prod",
              "callback_sha": "${{ github.sha }}"
            }

      - name: Wait for holdout results
        uses: lewagon/wait-on-check-action@v1.5.0
        with:
          ref: ${{ github.sha }}
          check-name: holdout-results
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 15
          allowed-conclusions: success,neutral
          fail-on-no-checks: false
        timeout-minutes: 12

  # â”€â”€â”€ Report â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Posts convergence results to the PR.

  report:
    name: "Report: PR Comment"
    runs-on: ubuntu-latest
    needs: [converge]
    if: github.event_name == 'pull_request' || github.event.pull_request.number
    permissions:
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      - name: Fetch holdout check run results
        id: holdout
        uses: actions/github-script@v7
        with:
          script: |
            // Look for the holdout-results check run on this commit
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              check_name: 'holdout-results',
            });

            const run = checkRuns.check_runs[0];
            if (run) {
              core.setOutput('score', run.output.title || 'N/A');
              core.setOutput('summary', run.output.summary || 'No summary available.');
              core.setOutput('conclusion', run.conclusion || 'unknown');
              core.setOutput('found', 'true');
            } else {
              core.setOutput('score', 'N/A');
              core.setOutput('summary', 'Holdout check run not found.');
              core.setOutput('conclusion', 'unknown');
              core.setOutput('found', 'false');
            }

      - name: Post convergence report
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
              state: 'open',
            });

            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping comment.');
              return;
            }

            const pr = prs[0];
            const sha = context.sha.substring(0, 7);
            const holdoutScore = '${{ steps.holdout.outputs.score }}';
            const holdoutSummary = `${{ steps.holdout.outputs.summary }}`;
            const holdoutConclusion = '${{ steps.holdout.outputs.conclusion }}';
            const holdoutFound = '${{ steps.holdout.outputs.found }}' === 'true';
            const holdoutIcon = holdoutConclusion === 'success' ? 'âœ…' : holdoutConclusion === 'failure' ? 'âŒ' : 'â³';

            const body = [
              `## ðŸ”¬ Convergence Report`,
              ``,
              `**Commit:** \`${sha}\``,
              `**Branch:** \`${context.ref.replace('refs/heads/', '')}\``,
              ``,
              `### Gates`,
              `| Check | Status |`,
              `|-------|--------|`,
              `| Frontend (lint + types + build) | âœ… Pass |`,
              `| Backend (pytest) | âœ… Pass |`,
              ``,
              `### Holdout Scenarios`,
              `| Metric | Result |`,
              `|--------|--------|`,
              `| Score | ${holdoutFound ? holdoutScore : 'â³ Pending'} |`,
              `| Status | ${holdoutIcon} ${holdoutConclusion} |`,
              ``,
              holdoutFound ? holdoutSummary : '*Waiting for holdout results...*',
              ``,
              `---`,
              `*Posted by the [Convergence Pipeline](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`,
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });

            const existing = comments.find(c =>
              c.body.includes('## ðŸ”¬ Convergence Report') &&
              c.user.type === 'Bot'
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });
            }
