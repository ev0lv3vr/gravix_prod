# converge.yml â€” Gravix Convergence Pipeline
# Runs gates + triggers holdout scenario validation on feature branches.
#
# Secrets required:
#   HOLDOUT_PAT â€” GitHub PAT with repo scope (cross-repo dispatch to gravix-holdouts)
#   Vercel token â€” already configured via Vercel GitHub integration

name: Converge

on:
  push:
    branches-ignore: [main]
  workflow_dispatch:

concurrency:
  group: converge-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â”€â”€â”€ Gates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Must pass before holdout scenarios run.
  # Mirrors ci.yml structure for consistency.

  gates-frontend:
    name: "Gate: Frontend (lint + types + build)"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Type check
        run: pnpm run type-check

      - name: Lint
        run: pnpm run lint

      - name: Build
        run: pnpm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: https://test.supabase.co
          NEXT_PUBLIC_SUPABASE_ANON_KEY: test-anon-key
          NEXT_PUBLIC_APP_URL: https://gravix.com

  gates-backend:
    name: "Gate: Backend (pytest)"
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.14
        uses: actions/setup-python@v5
        with:
          python-version: "3.14"
          cache: "pip"
          cache-dependency-path: |
            api/requirements.txt
            api/requirements-test.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r api/requirements.txt
          pip install -r api/requirements-test.txt

      - name: Run tests
        run: cd api && python -m pytest tests/ -v --timeout=120
        env:
          SUPABASE_URL: https://test.supabase.co
          SUPABASE_ANON_KEY: test-anon-key
          SUPABASE_SERVICE_KEY: test-service-key
          SUPABASE_JWT_SECRET: super-secret-jwt-test-key-at-least-32-chars-long!!
          ANTHROPIC_API_KEY: sk-ant-test-key
          CRON_SECRET: test-cron-secret
          STRIPE_SECRET_KEY: sk_test_fake
          STRIPE_WEBHOOK_SECRET: whsec_test_fake
          STRIPE_PRICE_ID_PRO: price_test_pro
          STRIPE_PRICE_ID_TEAM: price_test_team
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          RESEND_API_KEY: re_test_fake

  # â”€â”€â”€ Converge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Triggers holdout scenarios against the Vercel preview deployment.

  converge:
    name: "Converge: Holdout Scenarios"
    runs-on: ubuntu-latest
    needs: [gates-frontend, gates-backend]

    steps:
      - uses: actions/checkout@v4

      # Vercel preview URLs are auto-created by the Vercel GitHub integration.
      # We construct the expected URL from the branch name.
      - name: Determine preview URL
        id: preview
        run: |
          # Vercel auto-deploys preview URLs on push. Format varies by project config.
          # Default pattern: https://<project>-git-<branch>-<team>.vercel.app
          # Fallback: use branch-based URL
          BRANCH="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
          SANITIZED=$(echo "$BRANCH" | tr '/' '-' | tr '[:upper:]' '[:lower:]')
          PREVIEW_URL="https://gravix-prod-git-${SANITIZED}-ev0lv3vr.vercel.app"
          echo "url=${PREVIEW_URL}" >> "$GITHUB_OUTPUT"
          echo "ğŸ“ Preview URL: ${PREVIEW_URL}"

      # â”€â”€ Phase 2: Holdout Scenario Trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # TODO: Uncomment when gravix-holdouts has a scenario runner workflow.
      #
      # - name: Trigger holdout scenarios
      #   uses: peter-evans/repository-dispatch@v3
      #   with:
      #     token: ${{ secrets.HOLDOUT_PAT }}
      #     repository: ev0lv3vr/gravix-holdouts
      #     event-type: run-scenarios
      #     client-payload: >-
      #       {
      #         "preview_url": "${{ steps.preview.outputs.url }}",
      #         "sha": "${{ github.sha }}",
      #         "branch": "${{ github.ref_name }}",
      #         "callback_repo": "ev0lv3vr/gravix_prod",
      #         "callback_sha": "${{ github.sha }}"
      #       }
      #
      # - name: Wait for holdout results
      #   uses: lewagon/wait-on-check-action@v1.3.4
      #   with:
      #     ref: ${{ github.sha }}
      #     check-name: holdout-results
      #     repo-token: ${{ secrets.GITHUB_TOKEN }}
      #     wait-interval: 15
      #     allowed-conclusions: success,neutral

      - name: Holdout scenarios (placeholder)
        run: |
          echo "â³ Holdout scenario dispatch is Phase 2."
          echo "   Preview URL: ${{ steps.preview.outputs.url }}"
          echo "   Commit SHA:  ${{ github.sha }}"
          echo ""
          echo "Once gravix-holdouts has a runner workflow, uncomment the"
          echo "dispatch + wait steps above and add HOLDOUT_PAT secret."
          echo ""
          echo "For now, run holdouts locally: ./scripts/converge.sh"

  # â”€â”€â”€ Report â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Posts convergence results to the PR.

  report:
    name: "Report: PR Comment"
    runs-on: ubuntu-latest
    needs: [converge]
    if: github.event_name == 'pull_request' || github.event.pull_request.number
    permissions:
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      # TODO Phase 2: Download holdout results artifact and parse scores.
      # For now, post a status comment indicating gates passed.

      - name: Post convergence report
        uses: actions/github-script@v7
        with:
          script: |
            // Find the PR for this branch
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
              state: 'open',
            });

            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping comment.');
              return;
            }

            const pr = prs[0];
            const sha = context.sha.substring(0, 7);

            // TODO Phase 2: Parse actual holdout scores from artifact/check run
            const body = [
              `## ğŸ”¬ Convergence Report`,
              ``,
              `**Commit:** \`${sha}\``,
              `**Branch:** \`${context.ref.replace('refs/heads/', '')}\``,
              ``,
              `### Gates`,
              `| Check | Status |`,
              `|-------|--------|`,
              `| Frontend (lint + types + build) | âœ… Pass |`,
              `| Backend (pytest) | âœ… Pass |`,
              ``,
              `### Holdout Scenarios`,
              `â³ *Phase 2 â€” not yet wired. Run \`./scripts/converge.sh\` locally.*`,
              ``,
              `<!-- TODO Phase 2: Add scenario score table -->`,
              `<!-- | Scenario | Priority | Score | Status | -->`,
              `<!-- |----------|----------|-------|--------| -->`,
              ``,
              `---`,
              `*Posted by the [Convergence Pipeline](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`,
            ].join('\n');

            // Upsert: find existing convergence comment and update it
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });

            const existing = comments.find(c =>
              c.body.includes('## ğŸ”¬ Convergence Report') &&
              c.user.type === 'Bot'
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
              console.log(`Updated existing comment #${existing.id}`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });
              console.log('Created new convergence comment');
            }
