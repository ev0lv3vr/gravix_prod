# converge.yml â€” Gravix Convergence Pipeline
# Runs gates + triggers holdout scenario validation on feature branches.
#
# Secrets required:
#   HOLDOUT_PAT â€” GitHub PAT with repo scope (cross-repo dispatch to gravix-holdouts)
#   Vercel token â€” already configured via Vercel GitHub integration

name: Converge

on:
  push:
    branches-ignore: [main]
  workflow_dispatch:

concurrency:
  group: converge-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â”€â”€â”€ Gates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Must pass before holdout scenarios run.
  # Mirrors ci.yml structure for consistency.

  gates-frontend:
    name: "Gate: Frontend (lint + types + build)"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Type check
        run: pnpm run type-check

      - name: Lint
        run: pnpm run lint

      - name: Build
        run: pnpm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: https://test.supabase.co
          NEXT_PUBLIC_SUPABASE_ANON_KEY: test-anon-key
          NEXT_PUBLIC_APP_URL: https://gravix.com

  gates-backend:
    name: "Gate: Backend (pytest)"
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.14
        uses: actions/setup-python@v5
        with:
          python-version: "3.14"
          cache: "pip"
          cache-dependency-path: |
            api/requirements.txt
            api/requirements-test.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r api/requirements.txt
          pip install -r api/requirements-test.txt

      - name: Run tests
        run: cd api && python -m pytest tests/ -v --timeout=120
        env:
          SUPABASE_URL: https://test.supabase.co
          SUPABASE_ANON_KEY: test-anon-key
          SUPABASE_SERVICE_KEY: test-service-key
          SUPABASE_JWT_SECRET: super-secret-jwt-test-key-at-least-32-chars-long!!
          ANTHROPIC_API_KEY: sk-ant-test-key
          CRON_SECRET: test-cron-secret
          STRIPE_SECRET_KEY: sk_test_fake
          STRIPE_WEBHOOK_SECRET: whsec_test_fake
          STRIPE_PRICE_ID_PRO: price_test_pro
          STRIPE_PRICE_ID_TEAM: price_test_team
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          RESEND_API_KEY: re_test_fake

  # â”€â”€â”€ Converge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Triggers holdout scenarios against the Vercel preview deployment.

  converge:
    name: "Converge: Holdout Scenarios"
    runs-on: ubuntu-latest
    needs: [gates-frontend, gates-backend]

    steps:
      - uses: actions/checkout@v4

      # Vercel creates a GitHub Deployment with the preview URL on every push.
      # Poll the GitHub Deployments API until Vercel's deployment is active.
      - name: Wait for Vercel deployment
        id: preview
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.sha;
            const maxAttempts = 30;
            const delayMs = 15000;

            console.log(`â³ Waiting for Vercel deployment of ${sha.substring(0, 7)}...`);

            for (let i = 1; i <= maxAttempts; i++) {
              const { data: deployments } = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha,
                per_page: 5,
              });

              for (const dep of deployments) {
                const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: dep.id,
                  per_page: 1,
                });

                const latest = statuses[0];
                if (latest && latest.state === 'success' && latest.environment_url) {
                  console.log(`âœ… Found deployment: ${latest.environment_url}`);
                  core.setOutput('url', latest.environment_url);
                  return;
                }
              }

              console.log(`   Attempt ${i}/${maxAttempts} â€” not ready yet, waiting ${delayMs/1000}s...`);
              await new Promise(r => setTimeout(r, delayMs));
            }

            // Fallback to production
            console.log('âš ï¸  Timed out â€” falling back to gravix.com');
            core.setOutput('url', 'https://gravix.com');

      - name: Trigger holdout scenarios
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.HOLDOUT_PAT }}
          repository: ev0lv3vr/gravix-holdouts
          event-type: run-scenarios
          client-payload: >-
            {
              "preview_url": "${{ steps.preview.outputs.url }}",
              "sha": "${{ github.sha }}",
              "branch": "${{ github.ref_name }}",
              "callback_repo": "ev0lv3vr/gravix_prod",
              "callback_sha": "${{ github.sha }}"
            }

      - name: Wait for holdout results
        uses: lewagon/wait-on-check-action@v1.5.0
        with:
          ref: ${{ github.sha }}
          check-name: holdout-results
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 15
          allowed-conclusions: success,neutral
          fail-on-no-checks: false
        timeout-minutes: 25

  # â”€â”€â”€ Report â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Posts convergence results to the PR.

  report:
    name: "Report: PR Comment"
    runs-on: ubuntu-latest
    needs: [converge]
    if: github.event_name == 'pull_request' || github.event.pull_request.number
    permissions:
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      - name: Fetch holdout check run results
        id: holdout
        uses: actions/github-script@v7
        with:
          script: |
            // Look for the holdout-results check run on this commit
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              check_name: 'holdout-results',
            });

            const run = checkRuns.check_runs[0];
            if (run) {
              core.setOutput('score', run.output.title || 'N/A');
              core.setOutput('summary', run.output.summary || 'No summary available.');
              core.setOutput('conclusion', run.conclusion || 'unknown');
              core.setOutput('found', 'true');
            } else {
              core.setOutput('score', 'N/A');
              core.setOutput('summary', 'Holdout check run not found.');
              core.setOutput('conclusion', 'unknown');
              core.setOutput('found', 'false');
            }

      - name: Post convergence report
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
              state: 'open',
            });

            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping comment.');
              return;
            }

            const pr = prs[0];
            const sha = context.sha.substring(0, 7);
            const holdoutScore = '${{ steps.holdout.outputs.score }}';
            const holdoutSummary = `${{ steps.holdout.outputs.summary }}`;
            const holdoutConclusion = '${{ steps.holdout.outputs.conclusion }}';
            const holdoutFound = '${{ steps.holdout.outputs.found }}' === 'true';
            const holdoutIcon = holdoutConclusion === 'success' ? 'âœ…' : holdoutConclusion === 'failure' ? 'âŒ' : 'â³';

            const body = [
              `## ğŸ”¬ Convergence Report`,
              ``,
              `**Commit:** \`${sha}\``,
              `**Branch:** \`${context.ref.replace('refs/heads/', '')}\``,
              ``,
              `### Gates`,
              `| Check | Status |`,
              `|-------|--------|`,
              `| Frontend (lint + types + build) | âœ… Pass |`,
              `| Backend (pytest) | âœ… Pass |`,
              ``,
              `### Holdout Scenarios`,
              `| Metric | Result |`,
              `|--------|--------|`,
              `| Score | ${holdoutFound ? holdoutScore : 'â³ Pending'} |`,
              `| Status | ${holdoutIcon} ${holdoutConclusion} |`,
              ``,
              holdoutFound ? holdoutSummary : '*Waiting for holdout results...*',
              ``,
              `---`,
              `*Posted by the [Convergence Pipeline](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`,
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });

            const existing = comments.find(c =>
              c.body.includes('## ğŸ”¬ Convergence Report') &&
              c.user.type === 'Bot'
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });
            }
